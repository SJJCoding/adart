{"version":3,"sources":["StreamlitImgLabel.tsx","index.tsx","StreamlitImgLabel.module.css"],"names":["getSplinePath","points","radius","path","Path2D","firstPoint","moveTo","i","length","currentPoint","nextPoint","cp","arcTo","secondLastPoint","lastPoint","lineTo","closePath","toString","withStreamlitConnection","props","dataUri","_useState","useState","_useState2","_slicedToArray","mode","setMode","_useState3","_useState4","labels","setLabels","_useState5","fabric","Canvas","_useState6","canvas","setCanvas","_props$args","args","canvasWidth","canvasHeight","shapes","boxColor","imageData","_useState7","_useState8","newBBoxIndex","setNewBBoxIndex","invisCanvas","document","createElement","ctx","getContext","width","height","idata","createImageData","data","set","putImageData","toDataURL","useEffect","canvasTmp","enableRetinaScaling","backgroundImage","uniScaleTransform","_props$args2","forEach","shape","shapeType","top","left","label","console","log","add","Rect","fill","objectCaching","stroke","strokeWidth","strokeUniform","hasRotatingPoint","Text","fontFamily","fontSize","fontWeight","warn","concat","spline","Path","map","_ref","x","y","Streamlit","setFrameHeight","clearHandler","getObjects","rect","remove","sendCoordinates","returnLabels","rects","_objectSpread","getBoundingRect","setComponentValue","on","renderAll","off","onSelectMode","body","classList","window","matchMedia","addEventListener","e","matches","removeEventListener","_jsxs","_Fragment","children","_jsx","id","className","styles","dark","onClick","box","_toConsumableArray","selectObject","getActiveObject","selectIndex","indexOf","filter","_ref2","ReactDOM","render","React","StrictMode","StreamlitImgLabel","getElementById","module","exports"],"mappings":"2RAmCA,SAASA,EAAcC,EAAoBC,GACvC,IAAMC,EAAO,IAAIC,OACXC,EAAaJ,EAAO,GAC1BE,EAAKG,OAAOD,EAAW,GAAKH,EAAQG,EAAW,IAE/C,IAAK,IAAIE,EAAI,EAAGA,EAAIN,EAAOO,OAAS,EAAGD,IAAK,CAC1C,IAAME,EAAeR,EAAOM,GACtBG,EAAYT,EAAOM,EAAI,GACvBI,EAAK,CACTF,EAAa,IAAMC,EAAU,GAAKD,EAAa,IAAM,EACrDA,EAAa,IAAMC,EAAU,GAAKD,EAAa,IAAM,GAGvDN,EAAKS,MAAMD,EAAG,GAAIA,EAAG,GAAID,EAAU,GAAKR,EAAQQ,EAAU,GAAIR,EAChE,CAGA,IAAMW,EAAkBZ,EAAOA,EAAOO,OAAS,GACzCM,EAAYb,EAAOA,EAAOO,OAAS,GAqCzC,OApCAL,EAAKY,OAAOD,EAAU,GAAIA,EAAU,IACpCX,EAAKY,OAAOF,EAAgB,GAAIA,EAAgB,IAGhDV,EAAKS,MACHE,EAAU,GAAKZ,EACfY,EAAU,GACVA,EAAU,GAAKZ,EACfY,EAAU,GAAKZ,EACfA,GAEFC,EAAKS,MACHE,EAAU,GAAKZ,EACfY,EAAU,GAAK,EAAIZ,EACnBY,EAAU,GACVA,EAAU,GAAK,EAAIZ,EACnBA,GAEFC,EAAKS,MACHE,EAAU,GAAKZ,EACfY,EAAU,GAAK,EAAIZ,EACnBY,EAAU,GAAKZ,EACfY,EAAU,GAAKZ,EACfA,GAEFC,EAAKS,MACHE,EAAU,GAAKZ,EACfY,EAAU,GACVA,EAAU,GACVA,EAAU,GACVZ,GAIFC,EAAKa,YAEEb,EAAKc,UACd,CAEF,IA2UeC,eA3UW,SAACC,GACvB,IAiBIC,EAjBJC,EAAwBC,mBAAiB,SAAQC,EAAAC,YAAAH,EAAA,GAA1CI,EAAIF,EAAA,GAAEG,EAAOH,EAAA,GACpBI,EAA4BL,mBAAmB,IAAGM,EAAAJ,YAAAG,EAAA,GAA3CE,EAAMD,EAAA,GAAEE,EAASF,EAAA,GACxBG,EAA4BT,mBAAS,IAAIU,SAAOC,OAAO,KAAIC,EAAAV,YAAAO,EAAA,GAApDI,EAAMD,EAAA,GAAEE,EAASF,EAAA,GAExBG,EAA+ElB,EAAMmB,KAA7EC,EAAWF,EAAXE,YAAaC,EAAYH,EAAZG,aAAcC,EAAMJ,EAANI,OAAQC,EAAQL,EAARK,SAAUC,EAASN,EAATM,UACrDC,EAAwCtB,mBAAiB,GAAEuB,EAAArB,YAAAoB,EAAA,GAApDE,EAAYD,EAAA,GAAEE,EAAeF,EAAA,GAKhCG,EAAcC,SAASC,cAAc,UACrCC,EAAMH,EAAYI,WAAW,MAOjC,GALAJ,EAAYK,MAAQd,EACpBS,EAAYM,OAASd,EAIjBW,EAAK,CACL,IAAII,EAAQJ,EAAIK,gBAAgBjB,EAAaC,GAG7Ce,EAAME,KAAKC,IAAIf,GAGfQ,EAAIQ,aAAaJ,EAAO,EAAG,GAC3BnC,EAAU4B,EAAYY,WAC1B,MACIxC,EAAU,GAIdyC,qBAAU,WACN,IAAMC,EAAY,IAAI9B,SAAOC,OAAO,IAAK,CACrC8B,qBAAqB,EACrBC,gBAAiB5C,EACjB6C,mBAAmB,IAEvB7B,EAAU0B,EACd,GAAG,CAAC1C,IAIJyC,qBAAU,WACN,GAAI1B,EAAQ,CACR,IAAA+B,EAAyC/C,EAAMmB,KAAvCG,EAAMyB,EAANzB,OAAQC,EAAQwB,EAARxB,SAIhBD,EAAO0B,SAAQ,SAACC,GACZ,GAAwB,cAApBA,EAAMC,UAA2B,CACjC,IAAQC,EAAoCF,EAApCE,IAAKC,EAA+BH,EAA/BG,KAAMlB,EAAyBe,EAAzBf,MAAOC,EAAkBc,EAAlBd,OAAQkB,EAAUJ,EAAVI,MAElCC,QAAQC,IAAI,uBACZD,QAAQC,IAAIN,GACZjC,EAAOwC,IACH,IAAI3C,SAAO4C,KAAK,CACZL,OACAD,MACAO,KAAM,GACNxB,QACAC,SACAwB,eAAe,EACfC,OAAQrC,EACRsC,YAAa,EACbC,eAAe,EACfC,kBAAkB,KAG1B/C,EAAOwC,IACH,IAAI3C,SAAOmD,KAAKX,EAAO,CACnBD,KAAMA,EACND,IAAKA,EAAM,GACXc,WAAY,QACZC,SAAU,GACVC,WAAY,OACZT,KAAMnC,IAGlB,KAAO,IAAwB,WAApB0B,EAAMC,UA6Bb,YADAI,QAAQc,KAAK,kBAADC,OAAmBpB,EAAK,8BA3BpC,IAAQnE,EAA0BmE,EAA1BnE,OAAgBuE,GAAUJ,EAAlBlE,OAAkBkE,EAAVI,OAClBiB,EAAS,IAAIzD,SAAO0D,KACtB1F,EACAoE,EAAMnE,OAAO0F,KAAI,SAAAC,GAAO,MAAO,CAAVA,EAADC,EAAID,EAADE,EAAc,IACrC1B,EAAMlE,QAEN,CACA2E,KAAM,GACNE,OAAQrC,EACRsC,YAAa,EACbC,eAAe,EACfC,kBAAkB,IAGtB/C,EAAOwC,IAAIc,GAEXtD,EAAOwC,IACH,IAAI3C,SAAOmD,KAAKX,EAAO,CACnBD,KAAMtE,EAAO,GAAG4F,EAChBvB,IAAKrE,EAAO,GAAG6F,EAAI,GACnBV,WAAY,QACZC,SAAU,GACVC,WAAY,OACZT,KAAMnC,IAMlB,CACJ,GACJ,CAGAZ,EAAUW,EAAOkD,KAAI,SAACvB,GAAK,OAAKA,EAAMI,KAAK,KAI3CuB,IAAUC,gBAEd,GAAG,CAAC7D,EAAQK,EAAcD,EAAaI,EAAWF,EAAQC,IAG1D,IA2GMuD,EAAe,WACjBlD,EAAgB,GAChBZ,EAAO+D,aAAa/B,SAAQ,SAACgC,GAAI,OAAKhE,EAAOiE,OAAOD,EAAK,IACzDE,EAAgB,GACpB,EAGMA,EAAkB,SAACC,GACrBxE,EAAUwE,GACV,IAAMC,EAAQpE,EAAO+D,aAAaP,KAAI,SAACQ,EAAM5F,GAAC,OAAAiG,wBAAA,GACvCL,EAAKM,mBAAiB,IACzBjC,MAAO8B,EAAa/F,IAAE,IAE1BwF,IAAUW,kBAAkB,CAAEH,SAClC,EAGA1C,qBAAU,WACN,GAAK1B,EAAL,CASA,OADAA,EAAOwE,GAAG,mBALU,WAChBxE,EAAOyE,YACPP,EAAgBxE,EACpB,IAGO,WACHM,EAAO0E,IAAI,kBACf,CATA,CAUJ,IAGA,IAAMC,EAAe,SAACrF,GAClBC,EAAQD,GACK,SAATA,EAAiBwB,SAAS8D,KAAKC,UAAUrC,IAAI,aAC5C1B,SAAS8D,KAAKC,UAAUZ,OAAO,YACxC,EAyBA,OAvBAvC,qBAAU,WAgBN,OAdAoD,OACKC,WAAW,gCACXC,iBAAiB,UAAU,SAACC,GAAC,OAC1BN,EAAaM,EAAEC,QAAU,OAAS,QAAQ,IAIlDP,EACIG,OAAOC,WAAW,gCAAgCG,QAC5C,OACA,SAIH,WACHJ,OACKC,WAAW,gCACXI,oBAAoB,UAAU,WAAO,GAC9C,CACJ,GAAG,IAGCC,eAAAC,WAAA,CAAAC,SAAA,CACIC,cAAA,UACIC,GAAG,IACHC,UAAoB,SAATnG,EAAkBoG,IAAOC,KAAO,GAC3CzE,MAAOd,EACPe,OAAQd,IAEZ+E,eAAA,OAAKK,UAAoB,SAATnG,EAAkBoG,IAAOC,KAAO,GAAGL,SAAA,CAC/CC,cAAA,UACIE,UAAoB,SAATnG,EAAkBoG,IAAOC,KAAO,GAC3CC,QA5KM,WAClB,IAAMC,EATgB,CACtBzD,KAAoB,IAAdhC,EAAoC,EAAfO,EAC3BwB,IAAoB,IAAf9B,EAAqC,EAAfM,EAC3BO,MAAqB,GAAdd,EACPe,OAAuB,GAAfd,GAMRO,EAAgBD,EAAe,GAC/BX,EAAOwC,IACH,IAAI3C,SAAO4C,KAAI4B,wBAAC,CAAC,EACVwB,GAAG,IACNnD,KAAM,GACNC,eAAe,EACfC,OAAQ5D,EAAMmB,KAAKI,SACnBsC,YAAa,EACbC,eAAe,EACfC,kBAAkB,MAG1BmB,EAAgB,GAADb,OAAAyC,YAAKpG,GAAM,CAAE,KAChC,EA6JuC4F,SAC1B,kBAGDC,cAAA,UACIE,UAAoB,SAATnG,EAAkBoG,IAAOC,KAAO,GAC3CC,QAhKS,WACrB,IAAMG,EAAe/F,EAAOgG,kBACtBC,EAAcjG,EAAO+D,aAAamC,QAAQH,GAChD/F,EAAOiE,OAAO8B,GACd7B,EAAgBxE,EAAOyG,QAAO,SAAC9D,EAAOjE,GAAC,OAAKA,IAAM6H,CAAW,IACjE,EA2J0CX,SAC7B,kBAGDC,cAAA,UACIE,UAAoB,SAATnG,EAAkBoG,IAAOC,KAAO,GAC3CC,QA9JK,WACjB9B,IAEA,IAAMnC,EAAY,IAAI9B,SAAOC,OAAO,IAAK,CACrC8B,qBAAqB,EACrBC,gBAAiB5C,EACjB6C,mBAAmB,IAGvBxB,EAAO0B,SAAQ,SAACC,GACZ,GAAwB,cAApBA,EAAMC,UAA2B,CACjC,IAAQC,EAAoCF,EAApCE,IAAKC,EAA+BH,EAA/BG,KAAMlB,EAAyBe,EAAzBf,MAAOC,EAAkBc,EAAlBd,OAAQkB,EAAUJ,EAAVI,MAElCV,EAAUa,IACN,IAAI3C,SAAO4C,KAAK,CACZL,OACAD,MACAO,KAAM,GACNxB,QACAC,SACAwB,eAAe,EACfC,OAAQrC,EACRsC,YAAa,EACbC,eAAe,EACfC,kBAAkB,KAG1BpB,EAAUa,IACN,IAAI3C,SAAOmD,KAAKX,EAAO,CACnBD,KAAMA,EACND,IAAKA,EAAM,GACXc,WAAY,QACZC,SAAU,GACVC,WAAY,OACZT,KAAMnC,IAGlB,KAAO,IAAwB,WAApB0B,EAAMC,UA6Bb,YADAI,QAAQc,KAAK,kBAADC,OAAmBpB,EAAK,8BA3BpC,IAAQnE,EAA0BmE,EAA1BnE,OAAgBuE,GAAUJ,EAAlBlE,OAAkBkE,EAAVI,OAClBiB,EAAS,IAAIzD,SAAO0D,KACtB1F,EACEoE,EAAMnE,OAAO0F,KAAI,SAAA4C,GAAO,MAAO,CAAVA,EAAD1C,EAAI0C,EAADzC,EAAc,IACrC1B,EAAMlE,QAER,CACE2E,KAAM,GACNE,OAAQrC,EACRsC,YAAa,EACbC,eAAe,EACfC,kBAAkB,IAGxBpB,EAAUa,IAAIc,GAEd3B,EAAUa,IACN,IAAI3C,SAAOmD,KAAKX,EAAO,CACnBD,KAAMtE,EAAO,GAAG4F,EAChBvB,IAAKrE,EAAO,GAAG6F,EAAI,GACnBV,WAAY,QACZC,SAAU,GACVC,WAAY,OACZT,KAAMnC,IAMlB,CACJ,IACA2D,EAAgBxE,EACpB,EAwFsC4F,SACzB,UAGDC,cAAA,UACIE,UAAoB,SAATnG,EAAkBoG,IAAOC,KAAO,GAC3CC,QAAS9B,EAAawB,SACzB,mBAMjB,IClaAe,IAASC,OACPf,cAACgB,IAAMC,WAAU,CAAAlB,SACfC,cAACkB,EAAiB,MAEpB3F,SAAS4F,eAAe,Q,oBCP1BC,EAAOC,QAAU,CAAC,KAAO,gC","file":"static/js/main.cbdac199.chunk.js","sourcesContent":["import React, { useEffect, useState } from \"react\"\nimport {\n    ComponentProps,\n    Streamlit,\n    withStreamlitConnection,\n} from \"streamlit-component-lib\"\nimport { fabric } from \"fabric\"\nimport styles from \"./StreamlitImgLabel.module.css\"\n\ninterface RectProps {\n    top: number\n    left: number\n    width: number\n    height: number\n    label: string\n    shapeType: \"rectangle\"\n}\n\ninterface SplineProps {\n    points: Array<{ x: number; y: number }>\n    radius: number\n    label: string\n    shapeType: \"spline\"\n}\n\ntype ShapeProps = RectProps | SplineProps\n\ninterface PythonArgs {\n    canvasWidth: number\n    canvasHeight: number\n    shapes: ShapeProps[]\n    boxColor: string\n    imageData: Uint8ClampedArray\n}\n\nfunction getSplinePath(points: number[][], radius: number): string {\n    const path = new Path2D();\n    const firstPoint = points[0];\n    path.moveTo(firstPoint[0] + radius, firstPoint[1]);\n  \n    for (let i = 1; i < points.length - 2; i++) {\n      const currentPoint = points[i];\n      const nextPoint = points[i + 1];\n      const cp = [\n        currentPoint[0] + (nextPoint[0] - currentPoint[0]) / 2,\n        currentPoint[1] + (nextPoint[1] - currentPoint[1]) / 2,\n      ];\n  \n      path.arcTo(cp[0], cp[1], nextPoint[0] + radius, nextPoint[1], radius);\n    }\n  \n    // Draw the last two points as a straight line\n    const secondLastPoint = points[points.length - 2];\n    const lastPoint = points[points.length - 1];\n    path.lineTo(lastPoint[0], lastPoint[1]);\n    path.lineTo(secondLastPoint[0], secondLastPoint[1]);\n  \n    // Draw arcs for the rounded corners\n    path.arcTo(\n      lastPoint[0] - radius,\n      lastPoint[1],\n      lastPoint[0] - radius,\n      lastPoint[1] + radius,\n      radius\n    );\n    path.arcTo(\n      lastPoint[0] - radius,\n      lastPoint[1] + 2 * radius,\n      lastPoint[0],\n      lastPoint[1] + 2 * radius,\n      radius\n    );\n    path.arcTo(\n      lastPoint[0] + radius,\n      lastPoint[1] + 2 * radius,\n      lastPoint[0] + radius,\n      lastPoint[1] + radius,\n      radius\n    );\n    path.arcTo(\n      lastPoint[0] + radius,\n      lastPoint[1],\n      lastPoint[0],\n      lastPoint[1],\n      radius\n    );\n  \n    // Close the path\n    path.closePath();\n  \n    return path.toString();\n  }\n  \nconst StreamlitImgLabel = (props: ComponentProps) => {\n    const [mode, setMode] = useState<string>(\"light\")\n    const [labels, setLabels] = useState<string[]>([])\n    const [canvas, setCanvas] = useState(new fabric.Canvas(\"\"))\n    // const { canvasWidth, canvasHeight, imageData }: PythonArgs = props.args\n    const { canvasWidth, canvasHeight, shapes, boxColor, imageData }: PythonArgs = props.args\n    const [newBBoxIndex, setNewBBoxIndex] = useState<number>(0)\n  \n    /*\n     * Translate Python image data to a JavaScript Image\n     */\n    var invisCanvas = document.createElement(\"canvas\")\n    var ctx = invisCanvas.getContext(\"2d\")\n\n    invisCanvas.width = canvasWidth\n    invisCanvas.height = canvasHeight\n\n    // create imageData object\n    let dataUri: any\n    if (ctx) {\n        var idata = ctx.createImageData(canvasWidth, canvasHeight)\n\n        // set our buffer as source\n        idata.data.set(imageData)\n\n        // update canvas with new data\n        ctx.putImageData(idata, 0, 0)\n        dataUri = invisCanvas.toDataURL()\n    } else {\n        dataUri = \"\"\n    }\n\n    // Initialize canvas on mount and add shapes\n    useEffect(() => {\n        const canvasTmp = new fabric.Canvas(\"c\", {\n            enableRetinaScaling: false,\n            backgroundImage: dataUri,\n            uniScaleTransform: true,\n        })\n        setCanvas(canvasTmp)\n    }, [dataUri])\n\n\n    // Add shapes to the canvas\n    useEffect(() => {\n        if (canvas) {\n            const { shapes, boxColor }: PythonArgs = props.args\n            // console.log(\"shapes\")\n            // console.log(shapes)\n            // Add shapes to the canvas\n            shapes.forEach((shape) => {\n                if (shape.shapeType === \"rectangle\") {\n                    const { top, left, width, height, label } = shape\n\n                    console.log(\"rendering rectangle\")\n                    console.log(shape)\n                    canvas.add(\n                        new fabric.Rect({\n                            left,\n                            top,\n                            fill: \"\",\n                            width,\n                            height,\n                            objectCaching: true,\n                            stroke: boxColor,\n                            strokeWidth: 1,\n                            strokeUniform: true,\n                            hasRotatingPoint: false,\n                        })\n                    )\n                    canvas.add(\n                        new fabric.Text(label, {\n                            left: left,\n                            top: top + 20,\n                            fontFamily: \"Arial\",\n                            fontSize: 14,\n                            fontWeight: \"bold\",\n                            fill: boxColor,\n                        })\n                    )\n                } else if (shape.shapeType === \"spline\") {\n                    const { points, radius, label } = shape\n                    const spline = new fabric.Path(\n                        getSplinePath(\n                        shape.points.map(({ x, y }) => [x, y]),\n                        shape.radius\n                        ),\n                        {\n                        fill: \"\",\n                        stroke: boxColor,\n                        strokeWidth: 1,\n                        strokeUniform: true,\n                        hasRotatingPoint: false,\n                        }\n                    );\n                    canvas.add(spline)\n\n                    canvas.add(\n                        new fabric.Text(label, {\n                            left: points[0].x,\n                            top: points[0].y - 20,\n                            fontFamily: \"Arial\",\n                            fontSize: 14,\n                            fontWeight: \"bold\",\n                            fill: boxColor,\n                        })\n                    )\n                } else {\n                    console.warn(`Invalid shape \"${shape}\" specified\". Skipping...`)\n                    return\n                }\n            })\n        }\n\n        // Set labels\n        setLabels(shapes.map((shape) => shape.label))\n\n        // setCanvas(canvasTmp)\n\n        Streamlit.setFrameHeight()\n\n    }, [canvas, canvasHeight, canvasWidth, imageData, shapes, boxColor])\n\n    // Create defualt bounding box\n    const defaultBox = () => ({\n        left: canvasWidth * 0.15 + newBBoxIndex * 3,\n        top: canvasHeight * 0.15 + newBBoxIndex * 3,\n        width: canvasWidth * 0.2,\n        height: canvasHeight * 0.2,\n    })\n\n    // Add new bounding box to be image\n    const addBoxHandler = () => {\n        const box = defaultBox()\n        setNewBBoxIndex(newBBoxIndex + 1)\n        canvas.add(\n            new fabric.Rect({\n                ...box,\n                fill: \"\",\n                objectCaching: true,\n                stroke: props.args.boxColor,\n                strokeWidth: 1,\n                strokeUniform: true,\n                hasRotatingPoint: false,\n            })\n        )\n        sendCoordinates([...labels, \"\"])\n    }\n\n    // Remove the selected bounding box\n    const removeBoxHandler = () => {\n        const selectObject = canvas.getActiveObject()\n        const selectIndex = canvas.getObjects().indexOf(selectObject)\n        canvas.remove(selectObject)\n        sendCoordinates(labels.filter((label, i) => i !== selectIndex))\n    }\n\n    // Reset the shapes\n    const resetHandler = () => {\n        clearHandler()\n\n        const canvasTmp = new fabric.Canvas(\"c\", {\n            enableRetinaScaling: false,\n            backgroundImage: dataUri,\n            uniScaleTransform: true,\n        })\n\n        shapes.forEach((shape) => {\n            if (shape.shapeType === \"rectangle\") {\n                const { top, left, width, height, label } = shape\n\n                canvasTmp.add(\n                    new fabric.Rect({\n                        left,\n                        top,\n                        fill: \"\",\n                        width,\n                        height,\n                        objectCaching: true,\n                        stroke: boxColor,\n                        strokeWidth: 1,\n                        strokeUniform: true,\n                        hasRotatingPoint: false,\n                    })\n                )\n                canvasTmp.add(\n                    new fabric.Text(label, {\n                        left: left,\n                        top: top + 20,\n                        fontFamily: \"Arial\",\n                        fontSize: 14,\n                        fontWeight: \"bold\",\n                        fill: boxColor,\n                    })\n                )\n            } else if (shape.shapeType === \"spline\") {\n                const { points, radius, label } = shape\n                const spline = new fabric.Path(\n                    getSplinePath(\n                      shape.points.map(({ x, y }) => [x, y]),\n                      shape.radius\n                    ),\n                    {\n                      fill: \"\",\n                      stroke: boxColor,\n                      strokeWidth: 1,\n                      strokeUniform: true,\n                      hasRotatingPoint: false,\n                    }\n                  );\n                canvasTmp.add(spline)\n\n                canvasTmp.add(\n                    new fabric.Text(label, {\n                        left: points[0].x,\n                        top: points[0].y - 20,\n                        fontFamily: \"Arial\",\n                        fontSize: 14,\n                        fontWeight: \"bold\",\n                        fill: boxColor,\n                    })\n                )\n            } else {\n                console.warn(`Invalid shape \"${shape}\" specified\". Skipping...`)\n                return\n            }\n        })\n        sendCoordinates(labels)\n    }\n\n    // Remove all the bounding boxes\n    const clearHandler = () => {\n        setNewBBoxIndex(0)\n        canvas.getObjects().forEach((rect) => canvas.remove(rect))\n        sendCoordinates([])\n    }\n\n    // Send the coordinates of the rectangle back to streamlit.\n    const sendCoordinates = (returnLabels: string[]) => {\n        setLabels(returnLabels)\n        const rects = canvas.getObjects().map((rect, i) => ({\n            ...rect.getBoundingRect(),\n            label: returnLabels[i],\n        }))\n        Streamlit.setComponentValue({ rects })\n    }\n\n    // Update the bounding boxes when modified\n    useEffect(() => {\n        if (!canvas) {\n            return\n        }\n        const handleEvent = () => {\n            canvas.renderAll()\n            sendCoordinates(labels)\n        }\n\n        canvas.on(\"object:modified\", handleEvent)\n        return () => {\n            canvas.off(\"object:modified\")\n        }\n    })\n\n    // Adjust the theme according to the system\n    const onSelectMode = (mode: string) => {\n        setMode(mode)\n        if (mode === \"dark\") document.body.classList.add(\"dark-mode\")\n        else document.body.classList.remove(\"dark-mode\")\n    }\n\n    useEffect(() => {\n        // Add listener to update styles\n        window\n            .matchMedia(\"(prefers-color-scheme: dark)\")\n            .addEventListener(\"change\", (e) =>\n                onSelectMode(e.matches ? \"dark\" : \"light\")\n            )\n\n        // Setup dark/light mode for the first time\n        onSelectMode(\n            window.matchMedia(\"(prefers-color-scheme: dark)\").matches\n                ? \"dark\"\n                : \"light\"\n        )\n\n        // Remove listener\n        return () => {\n            window\n                .matchMedia(\"(prefers-color-scheme: dark)\")\n                .removeEventListener(\"change\", () => {})\n        }\n    }, [])\n\n    return (\n        <>\n            <canvas\n                id=\"c\"\n                className={mode === \"dark\" ? styles.dark : \"\"}\n                width={canvasWidth}\n                height={canvasHeight}\n            />\n            <div className={mode === \"dark\" ? styles.dark : \"\"}>\n                <button\n                    className={mode === \"dark\" ? styles.dark : \"\"}\n                    onClick={addBoxHandler}\n                >\n                    Mark Untagged\n                </button>\n                <button\n                    className={mode === \"dark\" ? styles.dark : \"\"}\n                    onClick={removeBoxHandler}\n                >\n                    Remove select\n                </button>\n                <button\n                    className={mode === \"dark\" ? styles.dark : \"\"}\n                    onClick={resetHandler}\n                >\n                    Reset\n                </button>\n                <button\n                    className={mode === \"dark\" ? styles.dark : \"\"}\n                    onClick={clearHandler}\n                >\n                    Clear all\n                </button>\n            </div>\n        </>\n    )\n}\n\nexport default withStreamlitConnection(StreamlitImgLabel)\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport StreamlitImgLabel from \"./StreamlitImgLabel\"\n\nReactDOM.render(\n  <React.StrictMode>\n    <StreamlitImgLabel />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n)\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"dark\":\"StreamlitImgLabel_dark__1ucLf\"};"],"sourceRoot":""}